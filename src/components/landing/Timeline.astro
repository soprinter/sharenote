---
const items = [
  { label: 'First Age', img: '/timeline/note-2.png' },
  { label: 'Middle Age',  img: '/timeline/note-3.png' },
  { label: 'Yesterday',  img: '/timeline/note-4.png' },
  { label: 'Now',  img: '/timeline/note-5.png' },
];
---
<section id="timeline" class="py-16 timeline-section">
  <div class="mx-auto max-w-[1040px] px-6">
    <h2 class="text-center mb-4 md:mb-6 text-2xl md:text-3xl lg:text-4xl leading-snug font-bold">Evolution of Notes</h2>
    <div class="timeline-scroller">
      <div class="timeline-flow" id="timeline-flow">
        <div class="cap start-cap" aria-hidden="true"></div>
        {items.map((it, idx) => (
          <Fragment>
          {(() => { const base = it.img.split('/').pop().replace('.png',''); return (
            <div class="timeline-item">
              <figure class="note-card">
                <picture>
                  <source type="image/avif" srcset={`/optimized/${base}-w320.avif 320w, /optimized/${base}-w480.avif 480w`} sizes="(min-width: 768px) 320px, 72vw" />
                  <source type="image/webp" srcset={`/optimized/${base}-w320.webp 320w, /optimized/${base}-w480.webp 480w`} sizes="(min-width: 768px) 320px, 72vw" />
                  <img src={it.img} srcset={`/optimized/${base}-w320.png 320w, /optimized/${base}-w480.png 480w`} sizes="(min-width: 768px) 320px, 72vw" alt={it.label} loading="lazy" decoding="async" draggable="false" />
                </picture>
              </figure>
              <figcaption class="note-caption">
                <div class="note-era">{it.label}</div>
              </figcaption>
            </div>
          ); })()}
          {idx < items.length - 1 && <div class="timeline-connector" aria-hidden="true"></div>}
          </Fragment>
        ))}
        <div class="cap end-cap" aria-hidden="true"></div>
      </div>
    </div>
  </div>
  <!-- SVG filters used to add a subtle crumpled-paper distortion to note images -->
  <svg aria-hidden="true" focusable="false" class="filters-defs" width="0" height="0" style="position:absolute; width:0; height:0; overflow:hidden">
    <filter id="crumple-paper" x="-10%" y="-10%" width="120%" height="120%" color-interpolation-filters="sRGB">
      <!-- Base fractal noise: low frequency, multiple octaves for gentle folds -->
      <feTurbulence type="fractalNoise" baseFrequency="0.015" numOctaves="3" seed="9" stitchTiles="stitch" result="noise" />
      <!-- Displace the source graphic with the noise to mimic paper creases -->
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="5" xChannelSelector="R" yChannelSelector="G" result="displaced" />
      <!-- Keep alpha from original -->
      <feComposite in="displaced" in2="SourceAlpha" operator="in" />
    </filter>
  </svg>
</section>

<style>
  /* Section background coherent with palette */
  .timeline-section {
    /* Light theme background for Evolution of Notes */
    --tl-bg: #edd4a8; /* light tan for Evolution of Notes */
    --next-bg: #edf9c5; /* color of the following section */
    /* Section‑local ink so type has optimal contrast on light tan */
    --tl-ink: color-mix(in oklab, var(--ink) 92%, #edd4a8 8%);
    --tl-ink-muted: color-mix(in oklab, var(--ink) 62%, #edd4a8 38%);
    /* Title color tuned to section palette */
    --tl-title: #82673f;
    /* Connector/line color aligned with section chart hues */
    --tl-line: var(--tl-title);
    background: var(--tl-bg);
    border-top: 1px solid var(--ink);
    border-left: none;
    border-right: none;
    position: relative;
    color: var(--tl-ink);
    overflow-x: clip;
  }
  /* Ensure the heading harmonizes with section palette */
  .timeline-section h2 { color: var(--tl-title); }
  /* Dark theme: keep hue reference while lowering luminance and contrast */
  :global(.dark) .timeline-section {
    /*
      We derive a deep, low-glare surface by blending the light-theme hues
      into the dark page background. The brown accent (#82643d) anchors the
      section’s identity in dark mode without introducing harsh contrast.
    */
    --tl-bg: color-mix(in oklab, #82643d 22%, var(--bg));
    --next-bg: color-mix(in oklab, #edf9c5 16%, var(--bg));
    --tl-ink: color-mix(in oklab, var(--ink) 88%, #82643d 12%);
    --tl-ink-muted: color-mix(in oklab, var(--ink) 60%, #82643d 40%);
    --tl-title: #d2b589;
    /* Keep line readable in dark while echoing section tone */
    --tl-line: color-mix(in oklab, #d2b589 82%, var(--ink) 18%);
    border-top-color: color-mix(in oklab, var(--ink) 25%, transparent);
  }
  /* Decorative soft blend from the previous section into timeline */
  .timeline-section::before {
    content: "";
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: -1px;
    width: 100%;
    height: 28px;
    pointer-events: none;
    background: linear-gradient(
      to top,
      var(--tl-bg) 0%,
      color-mix(in oklab, var(--tl-bg) 55%, var(--bg)) 55%,
      var(--bg) 100%
    );
  }
  /* Decorative soft blend into the next section (no hard separation) */
  .timeline-section::after {
    content: "";
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: -1px;
    width: 100%;
    height: 40px;
    pointer-events: none;
    background: linear-gradient(
      to bottom,
      var(--tl-bg) 0%,
      color-mix(in oklab, var(--tl-bg) 55%, var(--next-bg)) 55%,
      var(--next-bg) 100%
    );
  }
  .timeline-scroller { position: relative; }
  @media (min-width: 768px) {
    .timeline-scroller {
      /* True full-bleed width without growing the document */
      width: 100vw;
      margin-inline: calc(50% - 50vw);
      box-sizing: border-box;
      overflow-x: auto; scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch;
      padding: 0 56px; /* generous edge space so cards never touch viewport */
      /* Center items on snap */
      scroll-padding-left: 50%;
      scroll-padding-right: 50%;
      /* Hide scrollbar visuals while keeping scrolling */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
      cursor: grab;
    }
    .timeline-scroller.no-overflow { scroll-snap-type: none; cursor: default; }
    .timeline-scroller.auto-scroll { scroll-snap-type: none; }
    .timeline-scroller::-webkit-scrollbar { display: none; }
    /* Edge fades removed to avoid overlay on cards */
  }

  /* Drag state disables snap and selection for smooth panning */
  @media (min-width: 768px) {
    .timeline-scroller.dragging { cursor: grabbing; scroll-snap-type: none; }
    .timeline-scroller.dragging * { user-select: none; }
  }

  .timeline-flow {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 14px;
  }
  @media (min-width: 768px) {
    .timeline-flow { flex-direction: row; gap: 0; justify-content: center; }
  }

  .timeline-item { display: flex; flex-direction: column; align-items: center; }
  @media (min-width: 768px) {
    .timeline-item { scroll-snap-align: center; scroll-snap-stop: always; }
  }

  .note-card {
    margin: 0;
    width: min(68vw, 300px);
    aspect-ratio: 4 / 3;
    border-radius: 0;
    overflow: hidden;
    display: grid;
    place-items: center;
    position: relative;
    box-shadow: none;
  }
  .note-card img {
    width: 100%; height: 100%; object-fit: contain; object-position: center;
    display: block; image-rendering: auto;
    opacity: 0.78;
    /* Crumpled-paper distortion + slight tone control */
    filter: url(#crumple-paper) contrast(1.02) saturate(0.96);
    /* Prevent native image drag interfering with grab-scroll */
    -webkit-user-drag: none; user-select: none; pointer-events: none;

  }
  :global(.dark) .note-card img { opacity: 0.9; filter: url(#crumple-paper) contrast(0.98) saturate(0.94); }
  /* Crumpled paper overlay: subtle creases + fine grain */
  .note-card::after,
  .note-card::before {
    content: ""; position: absolute; inset: 0; pointer-events: none;
  }
  /* Dark creases using multiply; 3 large radial ripples */
  .note-card::after {
    background:
      radial-gradient(120px 60px at 22% 28%, rgba(0,0,0,0.12), transparent 60%),
      radial-gradient(160px 80px at 72% 38%, rgba(0,0,0,0.10), transparent 65%),
      radial-gradient(140px 70px at 42% 76%, rgba(0,0,0,0.08), transparent 65%),
      repeating-linear-gradient(0deg, rgba(0,0,0,0.03) 0 1px, transparent 1px 2px);
    mix-blend-mode: multiply;
    opacity: 0.55;
  }
  /* Soft highlights to sell the fold; use screen blend */
  .note-card::before {
    background:
      radial-gradient(90px 45px at 28% 32%, rgba(255,255,255,0.20), transparent 60%),
      radial-gradient(120px 60px at 64% 64%, rgba(255,255,255,0.14), transparent 65%);
    mix-blend-mode: screen;
    opacity: 0.45;
  }
  :global(.dark) .note-card::after { opacity: 0.35; }
  :global(.dark) .note-card::before { opacity: 0.25; }
  .note-caption { text-align: center; margin-top: 4px; }
  .note-era { font-size: 0.7rem; letter-spacing: 0.08em; text-transform: uppercase; color: var(--tl-line); }
  .note-year { font-weight: 800; font-size: clamp(18px, 3.2vw, 28px); }


  /* Connector between items switches orientation */
  .timeline-connector { background: var(--tl-line); opacity: 0.55; width: 2px; height: 32px; border-radius: 2px; pointer-events: none; }
  :global(.dark) .timeline-connector { opacity: 0.6; }
  @media (min-width: 768px) {
    /* Horizontal connector creates spacing between cards (no flex gap) */
    .timeline-connector {
      height: 2px; width: 20px; align-self: center;
      /* provide breathing room so it doesn't touch cards */
      margin-left: 8px; margin-right: 8px;
      /* total space consumed between cards = width + margins */
      flex: 0 0 36px;
      /* shift up roughly half the caption height so it aligns to card center */
      /* transform: translateY(-18px); */
    }
  }

  /* Caps create breathing room at both extremes when horizontal */
  .cap { display: none; }
  @media (min-width: 768px) {
    .cap { display: block; flex: 0 0 56px; height: 1px; }
  }

  /* No arrow UI on desktop/tablet; scroll with trackpad/mouse */
</style>

<script>
  (function () {
    const flow = document.getElementById('timeline-flow');
    if (!flow) return;
    const scroller = flow.parentElement; // .timeline-scroller
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)');
    const mq = window.matchMedia('(min-width: 768px)');

    let raf = 0;
    let last = 0;
    let dir = 1; // 1 => right, -1 => left
    let running = false;
    let userStopped = false;
    const SPEED = 48; // px per second

    function step(ts) {
      if (!running) return;
      if (!last) last = ts;
      const dt = (ts - last) / 1000;
      last = ts;

      const maxScroll = scroller.scrollWidth - scroller.clientWidth;
      if (maxScroll <= 0) { stop(); return; }

      let x = scroller.scrollLeft + dir * SPEED * dt;
      if (x <= 0) { x = 0; dir = 1; }
      else if (x >= maxScroll) { x = maxScroll; dir = -1; }
      scroller.scrollLeft = x;
      raf = requestAnimationFrame(step);
    }

    function hasOverflow() { return scroller.scrollWidth > scroller.clientWidth + 1; }
    function updateOverflowState() {
      const overflow = hasOverflow();
      scroller.classList.toggle('no-overflow', !overflow);
    }

    function start() {
      if (running || userStopped) return;
      if (!mq.matches || prefersReduced.matches) return;
      if (!scroller || !hasOverflow()) { updateOverflowState(); return; }
      updateOverflowState();
      running = true; last = 0;
      scroller.classList.add('auto-scroll');
      raf = requestAnimationFrame(step);
    }

    function stop(removeClass = true) {
      if (!running) return;
      running = false;
      cancelAnimationFrame(raf);
      if (removeClass) scroller.classList.remove('auto-scroll');
    }

    function stopByUser() {
      userStopped = true;
      // pause exactly where it is and keep snap disabled
      stop(false);
    }

    // Stop on any user intent to interact
    scroller.addEventListener('wheel', stopByUser, { passive: true });
    scroller.addEventListener('touchstart', stopByUser, { passive: true });
    scroller.addEventListener('pointerdown', stopByUser, { passive: true });
    scroller.addEventListener('mousedown', stopByUser);
    window.addEventListener('keydown', stopByUser);

    // React to environment changes
    mq.addEventListener?.('change', () => { if (!mq.matches) stop(); else if (!userStopped) start(); });
    prefersReduced.addEventListener?.('change', () => { if (prefersReduced.matches) stopByUser(); else if (!userStopped) start(); });
    window.addEventListener('resize', () => { updateOverflowState(); if (!userStopped) { stop(); start(); } });

    // Start when images finish loading (ensures overflow exists)
    const imgs = flow.querySelectorAll('img');
    let pending = imgs.length;
    if (pending === 0) {
      // no images to wait on
      setTimeout(() => { updateOverflowState(); if (!userStopped) start(); }, 50);
    } else {
      imgs.forEach((img) => {
        if (img.complete) {
          if (--pending === 0 && !userStopped) { updateOverflowState(); start(); }
        } else {
          img.addEventListener('load', () => { if (--pending === 0 && !userStopped) { updateOverflowState(); start(); } }, { once: true });
          img.addEventListener('error', () => { if (--pending === 0 && !userStopped) { updateOverflowState(); start(); } }, { once: true });
        }
      });
    }

    // Only run when the timeline is actually visible
    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver((entries) => {
        const entry = entries[0];
        if (!entry) return;
        if (entry.isIntersecting) {
          if (!userStopped) start();
        } else {
          stop();
        }
      }, { root: null, threshold: 0.2 });
      io.observe(scroller);
    }

    // Pause when tab is hidden, resume when visible (unless user stopped)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) stop();
      else if (!userStopped) start();
    });

    // Kick off after layout settles (safety net)
    requestAnimationFrame(updateOverflowState);
    setTimeout(() => { if (!userStopped) start(); }, 150);
  })();

  // Enable click-and-drag panning of the horizontal scroller on desktop
  (function enableDragScroll() {
    const flow = document.getElementById('timeline-flow');
    if (!flow) return;
    const scroller = flow.parentElement; // .timeline-scroller
    if (!scroller) return;

    let dragging = false;
    let startX = 0;
    let startLeft = 0;
    let lastX = 0;
    let lastT = 0;
    let vx = 0; // pixels per ms
    let momentumId = 0;

    function stopMomentum() { cancelAnimationFrame(momentumId); momentumId = 0; }
    function momentumStep() {
      if (Math.abs(vx) < 0.02) { scroller.classList.remove('dragging'); return; }
      scroller.scrollLeft -= vx * 16; // approx 60fps frame time
      vx *= 0.94; // friction
      momentumId = requestAnimationFrame(momentumStep);
    }

    function onPointerDown(ev) {
      if (ev.pointerType === 'touch') return; // touch already scrolls naturally
      if (scroller.scrollWidth <= scroller.clientWidth) return;
      dragging = true; stopMomentum();
      scroller.classList.add('dragging');
      startX = ev.clientX; startLeft = scroller.scrollLeft; lastX = startX; lastT = performance.now();
      try { scroller.setPointerCapture(ev.pointerId); } catch {}
    }
    function onPointerMove(ev) {
      if (!dragging) return;
      const dx = ev.clientX - startX;
      scroller.scrollLeft = startLeft - dx;
      const now = performance.now();
      const dt = now - lastT || 16;
      vx = (ev.clientX - lastX) / dt;
      lastX = ev.clientX; lastT = now;
      ev.preventDefault();
    }
    function onPointerUp(ev) {
      if (!dragging) return;
      dragging = false;
      try { scroller.releasePointerCapture(ev.pointerId); } catch {}
      // Start momentum if velocity is significant
      if (Math.abs(vx) > 0.04) momentumStep(); else scroller.classList.remove('dragging');
    }
    scroller.addEventListener('pointerdown', onPointerDown, { passive: true });
    scroller.addEventListener('dragstart', (e) => e.preventDefault());
    window.addEventListener('pointermove', onPointerMove, { passive: false });
    window.addEventListener('pointerup', onPointerUp, { passive: true });
    window.addEventListener('pointercancel', onPointerUp, { passive: true });
  })();
</script>
