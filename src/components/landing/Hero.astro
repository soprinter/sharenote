---
const heading = 'Print Your';
const prevWord = 'BANK';
const newWord = 'SHARE';
const noteSuffix = 'Note';
---
<section class="hero-section guilloche-bg">
  <div class="mx-auto px-6">
    <!-- Image width drives layout; text uses identical responsive width -->
    <div class="flex flex-col items-center" style="--hero-w: clamp(240px,50vw,420px);">
      <div class="my-0">
        <picture id="banknotehome-wrap" style="width: var(--hero-w); display:block;">
          <source type="image/avif" srcset="/optimized/pcb-w320.avif 320w, /optimized/pcb-w480.avif 480w, /optimized/pcb-w640.avif 640w" sizes="(min-width: 1024px) 420px, (min-width: 640px) 50vw, 90vw" />
          <source type="image/webp" srcset="/optimized/pcb-w320.webp 320w, /optimized/pcb-w480.webp 480w, /optimized/pcb-w640.webp 640w" sizes="(min-width: 1024px) 420px, (min-width: 640px) 50vw, 90vw" />
          <img src="/pcb.png" srcset="/optimized/pcb-w320.png 320w, /optimized/pcb-w480.png 480w, /optimized/pcb-w640.png 640w" sizes="(min-width: 1024px) 420px, (min-width: 640px) 50vw, 90vw" alt="Bank Note Home" class="block h-auto" loading="eager" decoding="async" />
        </picture>
      </div>

      <h1 id="hero-h1" class="block uppercase tracking-[0.08em] leading-tight font-extrabold text-center" style="width: var(--hero-w);">
        <span class="fitline">{heading}</span>
      </h1>
      <h2 id="hero-h2" class="block uppercase tracking-[0.08em] leading-tight font-extrabold mb-6 text-center" style="width: var(--hero-w);">
        <span class="fitline fitline-h2">
          <span class="slot-window">
            <span class="slot-reel">
              <span class="word-old">{prevWord}</span>
              <span class="word-new">{newWord}</span>
            </span>
          </span><span class="note-suffix">{noteSuffix}</span>
        </span>
      </h2>

      <div class="sub-head" style="width: var(--hero-w);">After coins, now notes.</div>
      <a href="#timeline" class="scroll-cue" aria-label="Scroll down to timeline">
        <span class="mouse-cue" aria-hidden="true">
          <span class="mouse-wheel"></span>
        </span>
        <span class="cue-label">Scroll</span>
      </a>
    </div>
  </div>
</section>

<style>
  .hero-section {
    height: calc(100svh - var(--header-h, 0px));
    box-sizing: border-box;
    display: grid; place-items: center; position: relative; overflow: hidden;
    /* Reserve space so the bottom cue never overlaps content */
    padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 76px);
    /* Improve mobile gesture handling while we intercept first upward swipe */
    overscroll-behavior-y: contain;
    /* Allow natural vertical scrolling; JS only intercepts when appropriate */
    touch-action: pan-y;
  }

  /* Ensure the tile repeats across full hero width regardless of global settings */
  .hero-section.guilloche-bg {
    background-repeat: repeat !important;
    background-size: 192px 192px !important;
    background-position: top center !important;
    /* Avoid viewport-anchored artifacts; tie background to the section box */
    background-attachment: scroll !important;
  }
  /* Prevent wrapping so we can size to a single line width */
  #hero-h1 .fitline, #hero-h2 .fitline { display: inline-block; white-space: nowrap; }
  /* Remove inter-element whitespace for h2 by using flex container */
  #hero-h2 .fitline-h2 { display: inline-flex; align-items: baseline; white-space: nowrap; gap: 0; }
  /* Sensible default sizes before JS runs (kept responsive) */
  #hero-h1 { font-size: clamp(28px, 5vw, 48px); }
  #hero-h2 { font-size: clamp(24px, 4.5vw, 44px); }
  #hero-h1, #hero-h2 { line-height: 1.1; }
  /* Slightly tighter uppercase kerning improves perceived fit */
  #hero-h1, #hero-h2 { letter-spacing: 0em; }
  .sub-head { color: var(--ink-muted); text-align: center; margin-top: 4px; margin-bottom: 2px; font-size: clamp(12px, 2.5vw, 14px); }
  .scroll-cue {
    position: absolute; left: 50%; bottom: calc(env(safe-area-inset-bottom, 0px) + 14px); transform: translateX(-50%);
    display: inline-flex; align-items: center; justify-content: center; flex-direction: column; gap: 6px;
    padding: 4px; color: var(--ink); background: transparent; border: 0; border-radius: 8px;
    z-index: 2; pointer-events: auto;
    transition: opacity 220ms ease, transform 220ms ease;
  }
  .scroll-cue.is-hidden { opacity: 0; transform: translateX(-50%) translateY(6px); pointer-events: none; }
  .mouse-cue { width: 24px; height: 38px; border: 2px solid currentColor; border-radius: 14px; display: inline-flex; align-items: flex-start; justify-content: center; padding-top: 8px; }
  .mouse-wheel { width: 6px; height: 6px; background: currentColor; border-radius: 50%; opacity: 0.95; animation: wheelSlide 1.6s ease-in-out infinite; }
  @keyframes wheelSlide { 0% { transform: translateY(0); opacity: 1; } 60% { transform: translateY(14px); opacity: 0; } 61% { transform: translateY(0); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
  .cue-label { font-size: clamp(10px, 1.6vw, 11px); letter-spacing: 0.08em; text-transform: uppercase; color: var(--ink); opacity: 0.85; }
  /* Prevent global link underline/border under the cue label */
  .scroll-cue, .scroll-cue .cue-label { text-decoration: none !important; }

  @media (max-height: 640px) {
    .hero-section { padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 60px); }
    .mouse-cue { width: 20px; height: 32px; }
  }
  .word-old {
    color: #dc2626; /* red */
    text-decoration: line-through;
    text-decoration-thickness: 0.12em;
    text-decoration-color: currentColor;
  }
  .word-new { color: var(--ink); }
  /* Slot-style word reel */
  .slot-window {
    display: inline-flex;
    align-items: baseline;
    /* Width/height are synchronized via JS to the max word size */
    width: auto;
    height: var(--slot-h, 1em);
    overflow: hidden;
    /* Slight baseline lift to match adjacent text visually */
    vertical-align: var(--slot-baseline-adjust, -0.06em);
  }
  .note-suffix { display: inline-block; line-height: 1; }
  .slot-reel {
    display: inline-block;
    will-change: transform;
  }
  .slot-reel > span {
    display: block;
    /* Force equal per-frame heights and center text */
    height: var(--slot-h, 1em);
    line-height: 1;
    display: flex;
    align-items: center;
  }
  @media (prefers-reduced-motion: reduce) {
    .slot-reel { transform: translateY(calc(-1 * var(--slot-h, 1em))); }
  }
</style>

<!-- Smooth scroll advance handled by inline script to avoid React hooks overhead -->


<script>
  (() => {
    type Cleanup = () => void;
    let cleanup: Cleanup | null = null;
    let initRAF = 0;

    function setupHero(): Cleanup {
      const cleanups: Cleanup[] = [];

      const heroList = Array.from(document.querySelectorAll<HTMLElement>('.hero-section'));
      const hero = heroList.length > 0 ? heroList[heroList.length - 1] : null;
      const scopedQuery: (selector: string) => Element | null = hero
        ? (selector) => hero.querySelector(selector)
        : () => null;
      const imgCandidate =
        (scopedQuery('#banknotehome-wrap img') as HTMLImageElement | null) ??
        (scopedQuery('#banknotehome') as HTMLImageElement | null);
      const h1 = scopedQuery('#hero-h1') as HTMLElement | null;
      const h2 = scopedQuery('#hero-h2') as HTMLElement | null;

      if (!hero || !imgCandidate || !h1 || !h2) {
        return () => {};
      }

      const imgEl = imgCandidate;
      const slotWindow = h2.querySelector<HTMLElement>('.slot-window');
      const slotReel = h2.querySelector<HTMLElement>('.slot-reel');
      const oldWord = h2.querySelector<HTMLElement>('.word-old');
      const newWord = h2.querySelector<HTMLElement>('.word-new');

      const prefersReducedMotion =
        window.matchMedia?.('(prefers-reduced-motion: reduce)').matches ?? false;

      let rAF = 0;
      let animId = 0;
      let phase = 0;
      let phaseStart = 0;
      let slotH = 0;
      let wOld = 0;
      let wNew = 0;
      let reelStarted = false;

      const T_DWELL_DANK = 1200;
      const T_MOVE_TO_SHARE = 900;
      const T_DWELL_SHARE = 1800;
      const T_MOVE_TO_DANK = 700;

      function fit(el: HTMLElement, targetWidth: number) {
        const span = el.querySelector<HTMLElement>('.fitline');
        if (!span) return;
        const baseline = 100;
        const prev = span.style.fontSize;
        span.style.fontSize = baseline + 'px';
        span.style.lineHeight = '1.1';
        const w = span.getBoundingClientRect().width || 1;
        const scale = targetWidth / w;
        const min = 16;
        const max = 120;
        const size = Math.max(min, Math.min(max, baseline * scale));
        el.style.fontSize = size + 'px';
        span.style.fontSize = prev;
      }

      function getTargetWidth(): number {
        return imgEl.getBoundingClientRect().width || 1;
      }

      function run() {
        const tw = getTargetWidth();

        if (slotWindow) {
          slotWindow.style.removeProperty('--slot-h');
          slotWindow.style.removeProperty('width');
          slotWindow.style.removeProperty('height');
        }

        fit(h1, tw);
        fit(h2, tw);

        if (slotWindow && slotReel && oldWord && newWord) {
          slotReel.style.transform = 'translateY(0)';

          const oldRect = oldWord.getBoundingClientRect();
          const newRect = newWord.getBoundingClientRect();
          const maxW = Math.ceil(Math.max(oldRect.width, newRect.width));
          const maxH = Math.ceil(Math.max(oldRect.height, newRect.height));

          slotWindow.style.setProperty('--slot-h', maxH + 'px');
          slotWindow.style.height = 'var(--slot-h)';

          wOld = Math.ceil(oldRect.width);
          wNew = Math.ceil(newRect.width);
          slotH = maxH;

          const showShare = phase === 1 || phase === 2;
          slotWindow.style.width = Math.ceil(showShare ? wNew : wOld) + 'px';
          slotReel.style.transform = showShare ? `translateY(${-slotH}px)` : 'translateY(0)';
        }
      }

      const onResize = () => {
        cancelAnimationFrame(rAF);
        rAF = requestAnimationFrame(run);
      };
      window.addEventListener('resize', onResize);
      cleanups.push(() => window.removeEventListener('resize', onResize));
      cleanups.push(() => cancelAnimationFrame(rAF));

      function updateSlotHeight() {
        if (!slotWindow) return;
        const h = getComputedStyle(slotWindow).getPropertyValue('--slot-h').trim();
        slotH = parseFloat(h || '0');
        if (!slotH && newWord) {
          slotH = Math.ceil(newWord.getBoundingClientRect().height) || 1;
        }
      }

      function easeOutCubic(t: number) {
        return 1 - Math.pow(1 - t, 3);
      }
      function easeInOutSine(t: number) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
      }

      function step(now: number) {
        if (!slotReel || !slotWindow || prefersReducedMotion) return;
        if (!phaseStart) phaseStart = now;
        const elapsed = now - phaseStart;
        switch (phase) {
          case 0:
            slotReel.style.transform = 'translateY(0)';
            slotWindow.style.width = Math.ceil(wOld || 0) + 'px';
            if (elapsed >= T_DWELL_DANK) {
              phase = 1;
              phaseStart = now;
            }
            break;
          case 1: {
            const p = Math.min(1, elapsed / T_MOVE_TO_SHARE);
            const e = easeOutCubic(p);
            slotReel.style.transform = `translateY(${-slotH * e}px)`;
            const w = (wOld || 0) + (wNew - (wOld || 0)) * e;
            slotWindow.style.width = Math.ceil(w) + 'px';
            if (p >= 1) {
              phase = 2;
              phaseStart = now;
            }
            break;
          }
          case 2:
            slotReel.style.transform = `translateY(${-slotH}px)`;
            slotWindow.style.width = Math.ceil(wNew || 0) + 'px';
            if (elapsed >= T_DWELL_SHARE) {
              phase = 3;
              phaseStart = now;
            }
            break;
          case 3: {
            const p = Math.min(1, elapsed / T_MOVE_TO_DANK);
            const e = easeInOutSine(p);
            slotReel.style.transform = `translateY(${-slotH * (1 - e)}px)`;
            const w = (wNew || 0) + ((wOld || 0) - (wNew || 0)) * e;
            slotWindow.style.width = Math.ceil(w) + 'px';
            if (p >= 1) {
              phase = 0;
              phaseStart = now;
            }
            break;
          }
        }
        animId = requestAnimationFrame(step);
      }

      function startReel() {
        if (!slotReel || prefersReducedMotion) return;
        cancelAnimationFrame(animId);
        updateSlotHeight();
        phase = 0;
        phaseStart = 0;
        animId = requestAnimationFrame(step);
      }

      const onImgLoad = () => {
        run();
        if (!reelStarted) {
          startReel();
          reelStarted = true;
        }
      };

      if (imgEl.complete) {
        onImgLoad();
      } else {
        imgEl.addEventListener('load', onImgLoad, { once: true });
        cleanups.push(() => imgEl.removeEventListener('load', onImgLoad));
      }
      cleanups.push(() => cancelAnimationFrame(animId));

      const next = document.getElementById('timeline');
      const cue = hero.querySelector<HTMLElement>('.scroll-cue');
      const threshold = (window.matchMedia?.('(pointer: coarse)').matches ?? false) ? 0.55 : 0.7;

      let inProgress = false;
      let touchStartY = 0;
      let heroRatio = 1;
      let ioHero: IntersectionObserver | null = null;
      let ioNext: IntersectionObserver | null = null;

      if ('IntersectionObserver' in window) {
        ioHero = new IntersectionObserver(
          (entries) => {
            heroRatio = entries[0]?.intersectionRatio ?? heroRatio;
            cue?.classList.toggle('is-hidden', heroRatio < 0.35);
          },
          { threshold: [0, 0.25, 0.35, 0.5, 0.75, 1] }
        );
        ioHero.observe(hero);
        cleanups.push(() => {
          ioHero?.disconnect();
          ioHero = null;
        });
      }

      cue?.classList.toggle('is-hidden', false);

      function mostlyInView() {
        return heroRatio >= threshold;
      }

      function getNextVisibleSection(): HTMLElement | null {
        if (!next) return null;
        let sibling = next.nextElementSibling;
        while (sibling) {
          if (sibling instanceof HTMLElement && sibling.tagName !== 'SCRIPT' && sibling.tagName !== 'TEMPLATE') {
            return sibling;
          }
          sibling = sibling.nextElementSibling;
        }
        return null;
      }

      function computeScrollTop(): number {
        if (!next) return window.scrollY;
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;
        const isDesktop = window.matchMedia?.('(min-width: 1024px)').matches ?? false;

        const nextRect = next.getBoundingClientRect();
        const nextTop = window.scrollY + nextRect.top;
        const nextBottom = nextTop + nextRect.height;

        if (!viewportHeight || !isDesktop) {
          return nextTop;
        }

        const below = getNextVisibleSection();
        let groupTop = nextTop;
        let groupBottom = nextBottom;
        if (below) {
          const belowRect = below.getBoundingClientRect();
          const belowBottom = window.scrollY + belowRect.bottom;
          groupBottom = Math.max(groupBottom, belowBottom);
        }

        const groupHeight = groupBottom - groupTop;
        if (groupHeight > 0 && groupHeight <= viewportHeight) {
          const center = groupTop + groupHeight / 2;
          return Math.max(0, center - viewportHeight / 2);
        }

        return nextTop;
      }

      function scrollToNext() {
        if (!next) return;
        const top = computeScrollTop();
        try {
          window.scrollTo({ top, behavior: 'smooth' });
        } catch {
          next.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }

      function startAdvance() {
        if (!next || inProgress || prefersReducedMotion) return;
        inProgress = true;
        try {
          window.dispatchEvent(new CustomEvent('timeline-stop-autoscroll'));
        } catch {}
        scrollToNext();
        if ('IntersectionObserver' in window) {
          ioNext?.disconnect();
          ioNext = new IntersectionObserver(
            (entries) => {
              const entry = entries[0];
              if (entry?.isIntersecting && entry.intersectionRatio >= 0.5) {
                inProgress = false;
                ioNext?.disconnect();
                ioNext = null;
              }
            },
            { threshold: [0.5] }
          );
          ioNext.observe(next);
        }
        window.setTimeout(() => {
          inProgress = false;
        }, 1800);
      }

      if (cue) {
        const onCueClick = (e: MouseEvent) => {
          e.preventDefault();
          startAdvance();
        };
        cue.addEventListener('click', onCueClick, { passive: false });
        cleanups.push(() => cue.removeEventListener('click', onCueClick));
      }

      const onWheel = (e: WheelEvent) => {
        if (e.deltaY <= 0 || !mostlyInView()) return;
        const active = document.activeElement as HTMLElement | null;
        if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) {
          return;
        }
        e.preventDefault();
        startAdvance();
      };
      hero.addEventListener('wheel', onWheel, { passive: false });
      cleanups.push(() => hero.removeEventListener('wheel', onWheel));

      const onKey = (e: KeyboardEvent) => {
        if (e.shiftKey || !mostlyInView()) return;
        if (e.key === 'PageDown' || e.key === 'ArrowDown' || e.key === ' ' || e.key === 'Spacebar') {
          e.preventDefault();
          startAdvance();
        }
      };
      window.addEventListener('keydown', onKey, { passive: false });
      cleanups.push(() => window.removeEventListener('keydown', onKey));

      const onTouchStart = (e: TouchEvent) => {
        touchStartY = e.touches[0]?.clientY || 0;
      };
      const onTouchMove = (e: TouchEvent) => {
        const y = e.touches[0]?.clientY || 0;
        const dy = touchStartY - y;
        if (dy < 18 || !mostlyInView()) return;
        e.preventDefault();
        startAdvance();
        touchStartY = 0;
      };
      hero.addEventListener('touchstart', onTouchStart, { passive: true });
      hero.addEventListener('touchmove', onTouchMove, { passive: false });
      cleanups.push(() => hero.removeEventListener('touchstart', onTouchStart));
      cleanups.push(() => hero.removeEventListener('touchmove', onTouchMove));

      cleanups.push(() => {
        ioNext?.disconnect();
        ioNext = null;
      });

      const updateHeaderSize = () => {
          const headerList = Array.from(document.querySelectorAll('header'));
          const header = headerList.length > 0 ? headerList[headerList.length - 1] : null;
        const el = header instanceof HTMLElement ? header : null;
        const height = el ? Math.round(el.getBoundingClientRect().height) : 0;
        document.documentElement.style.setProperty('--header-h', height + 'px');
      };
      const headerRAF = requestAnimationFrame(updateHeaderSize);
      cleanups.push(() => cancelAnimationFrame(headerRAF));
      window.addEventListener('resize', updateHeaderSize, { passive: true });
      cleanups.push(() => window.removeEventListener('resize', updateHeaderSize));

      return () => {
        cleanups.forEach((fn) => {
          try {
            fn();
          } catch {
            /* noop */
          }
        });
      };
    }

    function initHero() {
      cleanup?.();
      cleanup = setupHero();
    }

    function scheduleInitHero() {
      if (initRAF) {
        cancelAnimationFrame(initRAF);
        initRAF = 0;
      }
      initRAF = requestAnimationFrame(() => {
        initRAF = requestAnimationFrame(() => {
          initHero();
        });
      });
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', scheduleInitHero, { once: true });
    } else {
      scheduleInitHero();
    }

    const onPageLoad = () => scheduleInitHero();
    const onAfterSwap = () => scheduleInitHero();
    const onPageShow = () => {
      scheduleInitHero();
    };
    const onPageHide = () => {
      cleanup?.();
      cleanup = null;
      if (initRAF) {
        cancelAnimationFrame(initRAF);
        initRAF = 0;
      }
    };
    const onVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        scheduleInitHero();
      } else {
        onPageHide();
      }
    };
    const onBeforeSwap = () => {
      cleanup?.();
      cleanup = null;
      if (initRAF) {
        cancelAnimationFrame(initRAF);
        initRAF = 0;
      }
      document.removeEventListener('astro:page-load', onPageLoad);
      document.removeEventListener('astro:after-swap', onAfterSwap);
      document.removeEventListener('astro:before-swap', onBeforeSwap);
      window.removeEventListener('pageshow', onPageShow);
      window.removeEventListener('pagehide', onPageHide);
      document.removeEventListener('visibilitychange', onVisibilityChange);
    };

    document.addEventListener('astro:page-load', onPageLoad);
    document.addEventListener('astro:after-swap', onAfterSwap);
    document.addEventListener('astro:before-swap', onBeforeSwap);
    window.addEventListener('pageshow', onPageShow);
    window.addEventListener('pagehide', onPageHide);
    document.addEventListener('visibilitychange', onVisibilityChange);
  })();
</script>
